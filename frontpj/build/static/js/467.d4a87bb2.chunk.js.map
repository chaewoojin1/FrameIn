{"version":3,"file":"static/js/467.d4a87bb2.chunk.js","mappings":"0KAKA,MAiOA,EAjOiBA,KACf,MAAMC,GAAaC,EAAAA,EAAAA,KAAaC,GAAUA,EAAMC,aAC1CC,GAAYC,EAAAA,EAAAA,QAAO,OAClBC,EAASC,IAAcC,EAAAA,EAAAA,UAAS,KAChCC,EAAUC,IAAeF,EAAAA,EAAAA,UAAS,IAEnCG,GAAaN,EAAAA,EAAAA,QAAO,OAG1BO,EAAAA,EAAAA,YAAU,KACRR,EAAUS,QAAU,IAAIC,UALd,gCAQVV,EAAUS,QAAQE,OAAS,KAGzB,GAFAC,QAAQC,IAAI,gDAGVb,EAAUS,SACVT,EAAUS,QAAQK,aAAeJ,UAAUK,KAC3C,CACA,MAAMC,EAAe,SAASpB,EAAWqB,QACzCjB,EAAUS,QAAQS,KAAKF,EACzB,GAIFhB,EAAUS,QAAQU,UAAaC,IAC7B,MAAMC,EAAcC,KACbC,EAAQC,KAAmBC,GAAgBL,EAAMM,KAAKC,MAAM,KAC7DC,EAAcH,EAAaI,KAAK,KAAKC,OAGvCP,IAAW3B,EAAWqB,OACxBX,GAAayB,IACX,MAAMC,EAAc,IACfD,EACH,CACEE,KAAM,WACNC,KAAMN,EACNO,KAAMd,EACNE,SACAC,mBAIJ,OADAY,aAAaC,QAAQ,eAAgBC,KAAKC,UAAUP,IAC7CA,CAAW,GAEtB,EAIFhC,EAAUS,QAAQ+B,QAAU,KAC1B5B,QAAQC,IAAI,+CAAY,EAInB,KACDb,EAAUS,SACZT,EAAUS,QAAQgC,OACpB,IAED,IAGH,MAKMC,EAAoBC,UACxB,GAAKzC,EAAQ4B,OAMb,GAAI9B,EAAUS,SAAWT,EAAUS,QAAQK,aAAeJ,UAAUK,KAAM,CACxE,MAAMM,EAAcC,IACdsB,EAAmB,GAAGhD,EAAWqB,SAASrB,EAAWiD,YAAY3C,IAGvEF,EAAUS,QAAQS,KAAK0B,GAGvB,UACQE,EAAAA,EAAMC,KAAK,8CAA+C,CAC9DxB,OAAQ3B,EAAWqB,MACnBf,QAASA,IAEXU,QAAQC,IAAI,sFACd,CAAE,MAAOmC,GACPpC,QAAQoC,MAAM,yDAAuBA,EACvC,CAGA1C,GAAayB,IACX,MAAMC,EAAc,IACfD,EACH,CACEE,KAAM,OACNC,KAAMhC,EACNiC,KAAMd,EACNE,OAAQ3B,EAAWqB,MACnBO,eAAgB5B,EAAWiD,WAI/B,OADAT,aAAaC,QAAQ,eAAgBC,KAAKC,UAAUP,IAC7CA,CAAW,IAGpB7B,EAAW,GACb,MACES,QAAQC,IAAI,kGAxCZD,QAAQC,IAAI,sFAyCd,GAYFL,EAAAA,EAAAA,YAAU,KACJD,EAAWE,UACbF,EAAWE,QAAQwC,UAAY1C,EAAWE,QAAQyC,aACpD,GACC,CAAC7C,KAGJG,EAAAA,EAAAA,YAAU,KACR,MAAM2C,EAAiBf,aAAagB,QAAQ,gBACxCD,GACF7C,EAAYgC,KAAKe,MAAMF,GACzB,GACC,IAGH,MAAMG,EAAqBpB,IACzB,MAAMqB,EAAQrB,EAAKP,MAAM,KACzB,OAAO4B,EAAMC,OAAS,EAAID,EAAME,MAAM,GAAG5B,KAAK,KAAKC,OAASI,CAAI,EAU5DZ,EAAWoC,IACf,MAAMC,EAAMD,GAAQ,IAAIE,KACxB,IAAIC,EAAQF,EAAIG,WAChB,MAAMC,EAAOF,GAAS,GAAK,eAAO,eAClCA,EAAQA,EAAQ,IAAM,GACtB,MAAMG,EAAUL,EAAIM,aACpB,MAAO,GAAGF,KAAQF,KAASG,EAAU,GAAK,IAAMA,EAAUA,GAAS,EA8BrE,OACEE,EAAAA,EAAAA,KAAA,OAAKC,UAAU,gBAAeC,UAC5BC,EAAAA,EAAAA,MAAA,OAAKF,UAAU,cAAaC,SAAA,EAC1BF,EAAAA,EAAAA,KAAA,OAAKC,UAAU,aAAYC,UACzBF,EAAAA,EAAAA,KAAA,OAAAE,SAAK,uCAGPF,EAAAA,EAAAA,KAAA,OAAKC,UAAU,UAAUG,IAAK/D,EAAW6D,SAhCtC/D,EAASkE,KAAI,CAACC,EAAKC,KACxB,MAAMC,EACJD,EAAQ,GAAKpE,EAASoE,EAAQ,GAAGtC,OAASqC,EAAIrC,KAEhD,OACEkC,EAAAA,EAAAA,MAAAM,EAAAA,SAAA,CAAAP,SAAA,EACIM,IAAoBR,EAAAA,EAAAA,KAAA,OAAKC,UAAU,UAASC,UAACF,EAAAA,EAAAA,KAAA,QAAAE,SAAOI,EAAIrC,UAC1D+B,EAAAA,EAAAA,KAAA,OAEEC,UAAU,UACVS,MAAO,CACLC,eACEL,EAAIjD,SAAW3B,EAAWqB,MAAQ,WAAa,cACjDmD,UAEFC,EAAAA,EAAAA,MAAA,OAAKF,UAAU,cAAaC,SAAA,CACzBI,EAAIjD,SAAW3B,EAAWqB,QAASiD,EAAAA,EAAAA,KAAA,UAAAE,SAASI,EAAIhD,iBAAyB,IACzE8B,EAAkBkB,EAAItC,MAAM,QAT1BuC,KAYN,OAeHJ,EAAAA,EAAAA,MAAA,OAAKF,UAAU,iBAAgBC,SAAA,EAC7BF,EAAAA,EAAAA,KAAA,SACEjC,KAAK,OACL6C,MAAO5E,EACP6E,SA1ImB3D,IAC3BjB,EAAWiB,EAAM4D,OAAOF,MAAM,EA0ItBG,UAtFa7D,IACH,UAAdA,EAAM8D,KAAoB9D,EAAM+D,WAClCzC,IACAtB,EAAMgE,iBACR,EAmFQC,YAAY,0DACZlB,UAAU,WAEZD,EAAAA,EAAAA,KAAA,UAAQoB,QAAS5C,EAAmByB,UAAU,SAAQC,SAAC,oBAMxDxE,EAAW2F,UAAUC,SAAS,WAC7BtB,EAAAA,EAAAA,KAAA,OAAKC,UAAU,cAAaC,UAC1BF,EAAAA,EAAAA,KAAA,UAAQoB,QArEQG,KACxBrD,aAAasD,WAAW,gBACxBpF,EAAY,IACZM,QAAQC,IAAI,sIAA6B,EAkEGsD,UAAU,cAAaC,SAAC,mEAM9D,ECzNV,EANqBuB,KAEjBzB,EAAAA,EAAAA,KAACvE,EAAQ,G","sources":["components/ws/ChatRoom.jsx","pages/ws/ChatRoomPage.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\r\nimport { useSelector } from \"react-redux\";\r\nimport \"../../css/ChatRoom.css\"; // CSS 파일 import\r\nimport axios from \"axios\"; // axios 사용 (선택 사항, fetch도 가능합니다)\r\n\r\nconst ChatRoom = () => {\r\n  const loginState = useSelector((state) => state.loginSlice);\r\n  const webSocket = useRef(null);\r\n  const [message, setMessage] = useState(\"\"); // 입력된 메시지 상태\r\n  const [messages, setMessages] = useState([]); // 메시지 목록 상태\r\n  const url = \"ws://43.201.20.172:8090/chat\"; // 웹소켓 서버 URL\r\n  const chatBoxRef = useRef(null); // 채팅박스 DOM을 참조\r\n\r\n  // 웹소켓 연결 및 이벤트 핸들링\r\n  useEffect(() => {\r\n    webSocket.current = new WebSocket(url);\r\n\r\n    // 웹소켓 열렸을 때\r\n    webSocket.current.onopen = () => {\r\n      console.log(\"웹소켓 연결 성공\");\r\n      // 서버에 닉네임 전송\r\n      if (\r\n        webSocket.current &&\r\n        webSocket.current.readyState === WebSocket.OPEN\r\n      ) {\r\n        const emailMessage = `email:${loginState.email}`; // 닉네임을 서버에 전송\r\n        webSocket.current.send(emailMessage);\r\n      }\r\n    };\r\n\r\n    // 서버로부터 메시지 수신\r\n    webSocket.current.onmessage = (event) => {\r\n      const currentTime = getTime(); // 현재 시간 얻기\r\n      const [sender, senderNickname, ...messageParts] = event.data.split(\":\"); // 닉네임과 메시지 분리\r\n      const messageText = messageParts.join(\":\").trim(); // 메시지 본문\r\n\r\n      // 이미 받은 메시지가 사용자의 메시지라면, 중복 처리\r\n      if (sender !== loginState.email) {\r\n        setMessages((prevMessages) => {\r\n          const newMessages = [\r\n            ...prevMessages,\r\n            { \r\n              type: \"received\", \r\n              text: messageText, \r\n              time: currentTime, \r\n              sender, \r\n              senderNickname // 닉네임도 함께 저장\r\n            },\r\n          ];\r\n          localStorage.setItem(\"chatMessages\", JSON.stringify(newMessages)); // 로컬 스토리지에 메시지 저장\r\n          return newMessages;\r\n        });\r\n      }\r\n    };\r\n\r\n    // 웹소켓 연결 종료 시 처리\r\n    webSocket.current.onclose = () => {\r\n      console.log(\"웹소켓 연결 종료\");\r\n    };\r\n\r\n    // 컴포넌트 언마운트 시 웹소켓 종료\r\n    return () => {\r\n      if (webSocket.current) {\r\n        webSocket.current.close();\r\n      }\r\n    };\r\n  }, []); // 컴포넌트가 마운트 될 때만 실행\r\n\r\n  // 메시지 입력 핸들러\r\n  const handleMessageChange = (event) => {\r\n    setMessage(event.target.value);\r\n  };\r\n\r\n  // 메시지 보내기 핸들러\r\n  const handleSendMessage = async () => {\r\n    if (!message.trim()) {\r\n      // 메시지가 빈 값 또는 공백만 있을 경우 전송하지 않음\r\n      console.log(\"빈 메시지는 전송할 수 없습니다.\");\r\n      return; // 함수 종료\r\n    }\r\n\r\n    if (webSocket.current && webSocket.current.readyState === WebSocket.OPEN) {\r\n      const currentTime = getTime(); // 현재 시간 얻기\r\n      const formattedMessage = `${loginState.email}:${loginState.nickname}:${message}`;\r\n\r\n      // WebSocket을 통해 메시지 전송\r\n      webSocket.current.send(formattedMessage);\r\n\r\n      // 메시지를 REST API로도 보내기\r\n      try {\r\n        await axios.post(\"http://43.201.20.172:8090/api/chat/messages\", {\r\n          sender: loginState.email,\r\n          message: message,\r\n        });\r\n        console.log(\"메시지가 REST API에 전송되었습니다.\");\r\n      } catch (error) {\r\n        console.error(\"REST API 메시지 전송 실패:\", error);\r\n      }\r\n\r\n      // 메시지 상태 업데이트 및 로컬 스토리지 저장\r\n      setMessages((prevMessages) => {\r\n        const newMessages = [\r\n          ...prevMessages,\r\n          {\r\n            type: \"sent\",\r\n            text: message,\r\n            time: currentTime,\r\n            sender: loginState.email,\r\n            senderNickname: loginState.nickname, // 닉네임 추가\r\n          },\r\n        ];\r\n        localStorage.setItem(\"chatMessages\", JSON.stringify(newMessages)); // 로컬 스토리지에 메시지 저장\r\n        return newMessages;\r\n      });\r\n\r\n      setMessage(\"\"); // 메시지 전송 후 입력 필드를 비움\r\n    } else {\r\n      console.log(\"웹소켓 연결이 되어 있지 않습니다.\");\r\n    }\r\n  };\r\n\r\n  // 엔터키를 눌렀을 때 메시지 보내기 또는 줄바꿈 처리\r\n  const handleKeyDown = (event) => {\r\n    if (event.key === \"Enter\" && !event.shiftKey) {\r\n      handleSendMessage(); // 메시지 보내기\r\n      event.preventDefault(); // 기본 동작인 줄바꿈을 방지\r\n    }\r\n  };\r\n\r\n  // 새 메시지가 추가될 때마다 채팅박스 맨 아래로 스크롤\r\n  useEffect(() => {\r\n    if (chatBoxRef.current) {\r\n      chatBoxRef.current.scrollTop = chatBoxRef.current.scrollHeight;\r\n    }\r\n  }, [messages]); // messages 상태가 업데이트 될 때마다 실행\r\n\r\n  // 컴포넌트가 마운트될 때 로컬 스토리지에서 메시지 불러오기\r\n  useEffect(() => {\r\n    const storedMessages = localStorage.getItem(\"chatMessages\");\r\n    if (storedMessages) {\r\n      setMessages(JSON.parse(storedMessages)); // 로컬 스토리지에 저장된 메시지 불러오기\r\n    }\r\n  }, []);\r\n\r\n  // 메시지에서 닉네임만 제거하고 본문만 반환하는 함수\r\n  const formatMessageText = (text) => {\r\n    const parts = text.split(\":\"); // 닉네임과 메시지를 분리\r\n    return parts.length > 1 ? parts.slice(1).join(\":\").trim() : text; // 닉네임 부분을 제거한 나머지 텍스트 반환\r\n  };\r\n\r\n  // 로컬스토리지에 저장된 메시지 지우는 함수\r\n  const clearChatMessages = () => {\r\n    localStorage.removeItem(\"chatMessages\");\r\n    setMessages([]); // 상태도 초기화\r\n    console.log(\"로컬 스토리지에 저장된 메시지가 삭제되었습니다.\");\r\n  };\r\n\r\n  const getTime = (date) => {\r\n    const now = date || new Date();\r\n    let hours = now.getHours();\r\n    const ampm = hours >= 12 ? \"오후\" : \"오전\";\r\n    hours = hours % 12 || 12;\r\n    const minutes = now.getMinutes();\r\n    return `${ampm} ${hours}:${minutes < 10 ? \"0\" + minutes : minutes}`;\r\n  };\r\n\r\n  // 시간 비교하여 중복되는 시간 표시 방지\r\n  const renderMessages = () => {\r\n    return messages.map((msg, index) => {\r\n      const isSameTimeAsPrev =\r\n        index > 0 && messages[index - 1].time === msg.time; // 이전 메시지와 시간이 동일한지 확인\r\n\r\n      return (\r\n        <>\r\n          {!isSameTimeAsPrev && <div className=\"msgTime\"><span>{msg.time}</span></div>}\r\n          <div\r\n            key={index}\r\n            className=\"message\"\r\n            style={{\r\n              justifyContent:\r\n                msg.sender === loginState.email ? \"flex-end\" : \"flex-start\",\r\n            }}\r\n          >\r\n            <div className=\"messageText\">\r\n              {msg.sender !== loginState.email && <strong>{msg.senderNickname}</strong>} {/* 닉네임 표시 */}\r\n              {formatMessageText(msg.text)} {/* 메시지 본문 */}\r\n            </div>\r\n          </div>\r\n        </>\r\n      );\r\n    });\r\n  };\r\n\r\n  return (\r\n    <div className=\"chatContainer\">\r\n      <div className=\"chatContent\">\r\n        <div className=\"chatHeader\">\r\n          <div>영화 채팅방</div>\r\n        </div>\r\n        \r\n        <div className=\"chatBox\" ref={chatBoxRef}>\r\n          {renderMessages()}\r\n        </div>\r\n        <div className=\"inputContainer\">\r\n          <input\r\n            type=\"text\"\r\n            value={message}\r\n            onChange={handleMessageChange}\r\n            onKeyDown={handleKeyDown} // 엔터키 이벤트 추가\r\n            placeholder=\"메시지를 입력하세요\"\r\n            className=\"input\"\r\n          />\r\n          <button onClick={handleSendMessage} className=\"button\">\r\n            전송\r\n          </button>\r\n        </div>\r\n\r\n        {/* 로그인된 사용자가 ADMIN일 경우만 버튼 표시 */}\r\n        {loginState.roleNames.includes(\"ADMIN\") && (\r\n          <div className=\"adminButton\">\r\n            <button onClick={clearChatMessages} className=\"clearButton\">\r\n              저장된 메시지 지우기\r\n            </button>\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ChatRoom;\r\n","import React from 'react'\r\nimport ChatRoom from '../../components/ws/ChatRoom'\r\n\r\nconst ChatRoomPage = () => {\r\n  return (\r\n    <ChatRoom/>\r\n  )\r\n}\r\n\r\nexport default ChatRoomPage"],"names":["ChatRoom","loginState","useSelector","state","loginSlice","webSocket","useRef","message","setMessage","useState","messages","setMessages","chatBoxRef","useEffect","current","WebSocket","onopen","console","log","readyState","OPEN","emailMessage","email","send","onmessage","event","currentTime","getTime","sender","senderNickname","messageParts","data","split","messageText","join","trim","prevMessages","newMessages","type","text","time","localStorage","setItem","JSON","stringify","onclose","close","handleSendMessage","async","formattedMessage","nickname","axios","post","error","scrollTop","scrollHeight","storedMessages","getItem","parse","formatMessageText","parts","length","slice","date","now","Date","hours","getHours","ampm","minutes","getMinutes","_jsx","className","children","_jsxs","ref","map","msg","index","isSameTimeAsPrev","_Fragment","style","justifyContent","value","onChange","target","onKeyDown","key","shiftKey","preventDefault","placeholder","onClick","roleNames","includes","clearChatMessages","removeItem","ChatRoomPage"],"sourceRoot":""}