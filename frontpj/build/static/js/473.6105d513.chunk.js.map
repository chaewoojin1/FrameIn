{"version":3,"file":"static/js/473.6105d513.chunk.js","mappings":"mHAAgBA,OAAOC,eACGD,OAAOE,sBACdF,OAAOG,UAAUC,eACjBJ,OAAOG,UAAUE,qBAHpC,IAkBIC,EAAmB,IAAI,eAAeC,UAAU,QAAQC,KAAKC,GAASA,EAAKC,WAAW,KAKtFC,GAJiC,SAASD,WAAW,GACtB,SAASA,WAAW,GAGZ,CAEzC,GAAI,GACJE,SAAQ,SACRC,SAAQ,SACRC,SAAQ,eACRC,SAAQ,SACRC,SAAQ,eACRC,SAAQ,eACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,eACRC,SAAQ,eACRC,SAAQ,eACRC,SAAQ,eACRC,SAAQ,eACRC,SAAQ,eACRC,SAAQ,eACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,eACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,WAENC,EAA+B,CACjCC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,eACRC,SAAQ,eACRC,SAAQ,eACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,eACRC,SAAQ,eACRC,SAAQ,eACRC,SAAQ,SACRC,SAAQ,SACRC,SAAQ,eACRC,SAAQ,UAENC,EAAY,CACd,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,UAEchE,OAAOiE,OAAOvB,GACb,CACf,GACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,UACAlC,KAAK0D,GAAcvD,EAAqCuD,KA2d1D,IAAIC,EAAkB,CACpBC,eAAgB9D,EAAiB,GAEjC+D,gBAAiB/D,EAAiB,GAElCgE,gBAAiBhE,EAAiB,GAElCiE,aAAcjE,EAAiB,GAE/BkE,cAAelE,EAAiB,GAEhCmE,cAAenE,EAAiB,IAKlC,SAASoE,EAAYC,GACnB,OAAOA,EAAKpE,UAAU,OAAOqE,QAAQC,EAAwB,IAAID,QAAQE,GAA4BC,GAAOf,EAAUe,EAAGrE,WAAW,GAAK,OAC3I,CACA,IAAImE,EAAyB,IAAIG,OAC/B,QAAQb,EAAgBC,eAAea,SAAS,UAAUd,EAAgBI,aAAaU,SAAS,wBAChG,MAEEH,EAA4B,IAAIE,OAClC,OAAOb,EAAgBC,eAAea,SAAS,UAAUd,EAAgBI,aAAaU,SAAS,OAC/F,I","sources":["../node_modules/es-hangul/dist/index.mjs"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\n\n// src/_internal/constants.ts\nvar _JASO_HANGUL_NFD = [...\"\\uAC01\\uD7A3\".normalize(\"NFD\")].map((char) => char.charCodeAt(0));\nvar COMPLETE_HANGUL_START_CHARCODE = \"\\uAC00\".charCodeAt(0);\nvar COMPLETE_HANGUL_END_CHARCODE = \"\\uD7A3\".charCodeAt(0);\nvar NUMBER_OF_JONGSEONG = 28;\nvar NUMBER_OF_JUNGSEONG = 21;\nvar DISASSEMBLED_CONSONANTS_BY_CONSONANT = {\n  // 종성이 없는 경우 '빈' 초성으로 관리하는 것이 편리하여, 빈 문자열도 포함한다.\n  \"\": \"\",\n  \\u3131: \"\\u3131\",\n  \\u3132: \"\\u3132\",\n  \\u3133: \"\\u3131\\u3145\",\n  \\u3134: \"\\u3134\",\n  \\u3135: \"\\u3134\\u3148\",\n  \\u3136: \"\\u3134\\u314E\",\n  \\u3137: \"\\u3137\",\n  \\u3138: \"\\u3138\",\n  \\u3139: \"\\u3139\",\n  \\u313A: \"\\u3139\\u3131\",\n  \\u313B: \"\\u3139\\u3141\",\n  \\u313C: \"\\u3139\\u3142\",\n  \\u313D: \"\\u3139\\u3145\",\n  \\u313E: \"\\u3139\\u314C\",\n  \\u313F: \"\\u3139\\u314D\",\n  \\u3140: \"\\u3139\\u314E\",\n  \\u3141: \"\\u3141\",\n  \\u3142: \"\\u3142\",\n  \\u3143: \"\\u3143\",\n  \\u3144: \"\\u3142\\u3145\",\n  \\u3145: \"\\u3145\",\n  \\u3146: \"\\u3146\",\n  \\u3147: \"\\u3147\",\n  \\u3148: \"\\u3148\",\n  \\u3149: \"\\u3149\",\n  \\u314A: \"\\u314A\",\n  \\u314B: \"\\u314B\",\n  \\u314C: \"\\u314C\",\n  \\u314D: \"\\u314D\",\n  \\u314E: \"\\u314E\"\n};\nvar DISASSEMBLED_VOWELS_BY_VOWEL = {\n  \\u314F: \"\\u314F\",\n  \\u3150: \"\\u3150\",\n  \\u3151: \"\\u3151\",\n  \\u3152: \"\\u3152\",\n  \\u3153: \"\\u3153\",\n  \\u3154: \"\\u3154\",\n  \\u3155: \"\\u3155\",\n  \\u3156: \"\\u3156\",\n  \\u3157: \"\\u3157\",\n  \\u3158: \"\\u3157\\u314F\",\n  \\u3159: \"\\u3157\\u3150\",\n  \\u315A: \"\\u3157\\u3163\",\n  \\u315B: \"\\u315B\",\n  \\u315C: \"\\u315C\",\n  \\u315D: \"\\u315C\\u3153\",\n  \\u315E: \"\\u315C\\u3154\",\n  \\u315F: \"\\u315C\\u3163\",\n  \\u3160: \"\\u3160\",\n  \\u3161: \"\\u3161\",\n  \\u3162: \"\\u3161\\u3163\",\n  \\u3163: \"\\u3163\"\n};\nvar CHOSEONGS = [\n  \"\\u3131\",\n  \"\\u3132\",\n  \"\\u3134\",\n  \"\\u3137\",\n  \"\\u3138\",\n  \"\\u3139\",\n  \"\\u3141\",\n  \"\\u3142\",\n  \"\\u3143\",\n  \"\\u3145\",\n  \"\\u3146\",\n  \"\\u3147\",\n  \"\\u3148\",\n  \"\\u3149\",\n  \"\\u314A\",\n  \"\\u314B\",\n  \"\\u314C\",\n  \"\\u314D\",\n  \"\\u314E\"\n];\nvar JUNSEONGS = Object.values(DISASSEMBLED_VOWELS_BY_VOWEL);\nvar JONGSEONGS = [\n  \"\",\n  \"\\u3131\",\n  \"\\u3132\",\n  \"\\u3133\",\n  \"\\u3134\",\n  \"\\u3135\",\n  \"\\u3136\",\n  \"\\u3137\",\n  \"\\u3139\",\n  \"\\u313A\",\n  \"\\u313B\",\n  \"\\u313C\",\n  \"\\u313D\",\n  \"\\u313E\",\n  \"\\u313F\",\n  \"\\u3140\",\n  \"\\u3141\",\n  \"\\u3142\",\n  \"\\u3144\",\n  \"\\u3145\",\n  \"\\u3146\",\n  \"\\u3147\",\n  \"\\u3148\",\n  \"\\u314A\",\n  \"\\u314B\",\n  \"\\u314C\",\n  \"\\u314D\",\n  \"\\u314E\"\n].map((consonant) => DISASSEMBLED_CONSONANTS_BY_CONSONANT[consonant]);\nvar HANGUL_DIGITS = [\n  \"\",\n  \"\\uB9CC\",\n  \"\\uC5B5\",\n  \"\\uC870\",\n  \"\\uACBD\",\n  \"\\uD574\",\n  \"\\uC790\",\n  \"\\uC591\",\n  \"\\uAD6C\",\n  \"\\uAC04\",\n  \"\\uC815\",\n  \"\\uC7AC\",\n  \"\\uADF9\",\n  \"\\uD56D\\uD558\\uC0AC\",\n  \"\\uC544\\uC2B9\\uAE30\",\n  \"\\uB098\\uC720\\uD0C0\",\n  \"\\uBD88\\uAC00\\uC0AC\\uC758\",\n  \"\\uBB34\\uB7C9\\uB300\\uC218\",\n  \"\\uAC81\",\n  \"\\uC5C5\"\n];\nvar HANGUL_DIGITS_MAX = HANGUL_DIGITS.length * 4;\nvar HANGUL_NUMBERS = [\"\", \"\\uC77C\", \"\\uC774\", \"\\uC0BC\", \"\\uC0AC\", \"\\uC624\", \"\\uC721\", \"\\uCE60\", \"\\uD314\", \"\\uAD6C\"];\nvar HANGUL_NUMBERS_FOR_DECIMAL = [\"\\uC601\", \"\\uC77C\", \"\\uC774\", \"\\uC0BC\", \"\\uC0AC\", \"\\uC624\", \"\\uC721\", \"\\uCE60\", \"\\uD314\", \"\\uAD6C\"];\nvar HANGUL_CARDINAL = [\"\", \"\\uC2ED\", \"\\uBC31\", \"\\uCC9C\"];\n\n// src/amountToHangul/amountToHangul.ts\nfunction amountToHangul(amount) {\n  const [rawIntegerPart, rawDecimalPart] = String(amount).replace(/[^\\d.]+/g, \"\").split(\".\");\n  const integerPart = rawIntegerPart !== \"0\" ? rawIntegerPart.replace(/^0+/, \"\") : rawIntegerPart;\n  if (integerPart.length > HANGUL_DIGITS_MAX) {\n    throw new Error(`convert range exceeded : ${amount}`);\n  }\n  const decimalPart = rawDecimalPart == null ? void 0 : rawDecimalPart.replace(/0+$/, \"\");\n  const result = [];\n  let pronunDigits = true;\n  if (integerPart === \"0\" || integerPart === \"\" && rawDecimalPart) {\n    result.push(HANGUL_NUMBERS_FOR_DECIMAL[0]);\n  } else {\n    for (let i = 0; i < integerPart.length - 1; i++) {\n      const digit = integerPart.length - i - 1;\n      if (integerPart[i] > \"1\" || digit % 4 === 0 || i === 0) {\n        const hangulNumber = HANGUL_NUMBERS[Number(integerPart[i])];\n        if (hangulNumber) {\n          result.push(hangulNumber);\n          pronunDigits = true;\n        }\n      }\n      if (pronunDigits && digit % 4 === 0) {\n        result.push(HANGUL_DIGITS[digit / 4]);\n        pronunDigits = false;\n      }\n      if (integerPart[i] !== \"0\") {\n        result.push(HANGUL_CARDINAL[digit % 4]);\n      }\n    }\n    result.push(HANGUL_NUMBERS[Number(integerPart[integerPart.length - 1])]);\n  }\n  if (decimalPart) {\n    result.push(\"\\uC810\");\n    for (let i = 0; i < decimalPart.length; i++) {\n      result.push(HANGUL_NUMBERS_FOR_DECIMAL[Number(decimalPart[i])]);\n    }\n  }\n  return result.join(\"\");\n}\n\n// src/_internal/index.ts\nfunction excludeLastElement(array) {\n  const lastElement = array[array.length - 1];\n  return [array.slice(0, -1), lastElement != null ? lastElement : \"\"];\n}\nfunction joinString(...args) {\n  return args.join(\"\");\n}\nfunction isBlank(character) {\n  return /^\\s$/.test(character);\n}\nfunction assert(condition, errorMessage) {\n  if (condition === false) {\n    throw new Error(errorMessage != null ? errorMessage : \"Invalid condition\");\n  }\n}\nfunction isNotUndefined(value) {\n  return value !== void 0;\n}\nfunction arrayIncludes(array, item, fromIndex) {\n  return array.includes(item, fromIndex);\n}\nfunction hasValueInReadOnlyStringList(list, value) {\n  return list.some((item) => item === value);\n}\nfunction hasProperty(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\n// src/disassembleCompleteCharacter/disassembleCompleteCharacter.ts\nfunction disassembleCompleteCharacter(letter) {\n  const charCode = letter.charCodeAt(0);\n  const isCompleteHangul = COMPLETE_HANGUL_START_CHARCODE <= charCode && charCode <= COMPLETE_HANGUL_END_CHARCODE;\n  if (!isCompleteHangul) {\n    return void 0;\n  }\n  const hangulCode = charCode - COMPLETE_HANGUL_START_CHARCODE;\n  const jongseongIndex = hangulCode % NUMBER_OF_JONGSEONG;\n  const jungseongIndex = (hangulCode - jongseongIndex) / NUMBER_OF_JONGSEONG % NUMBER_OF_JUNGSEONG;\n  const choseongIndex = Math.floor((hangulCode - jongseongIndex) / NUMBER_OF_JONGSEONG / NUMBER_OF_JUNGSEONG);\n  return {\n    choseong: CHOSEONGS[choseongIndex],\n    jungseong: JUNSEONGS[jungseongIndex],\n    jongseong: JONGSEONGS[jongseongIndex]\n  };\n}\n\n// src/disassembleToGroups/disassembleToGroups.ts\nfunction disassembleToGroups(str) {\n  const result = [];\n  for (const letter of str) {\n    const disassembledComplete = disassembleCompleteCharacter(letter);\n    if (disassembledComplete != null) {\n      result.push([\n        ...disassembledComplete.choseong,\n        ...disassembledComplete.jungseong,\n        ...disassembledComplete.jongseong\n      ]);\n      continue;\n    }\n    if (hasProperty(DISASSEMBLED_CONSONANTS_BY_CONSONANT, letter)) {\n      const disassembledConsonant = DISASSEMBLED_CONSONANTS_BY_CONSONANT[letter];\n      result.push([...disassembledConsonant]);\n      continue;\n    }\n    if (hasProperty(DISASSEMBLED_VOWELS_BY_VOWEL, letter)) {\n      const disassembledVowel = DISASSEMBLED_VOWELS_BY_VOWEL[letter];\n      result.push([...disassembledVowel]);\n      continue;\n    }\n    result.push([letter]);\n  }\n  return result;\n}\n\n// src/disassemble/disassemble.ts\nfunction disassemble(str) {\n  return disassembleToGroups(str).reduce((hanguls, disassembleds) => `${hanguls}${disassembleds.join(\"\")}`, \"\");\n}\n\n// src/canBeChoseong/canBeChoseong.ts\nfunction canBeChoseong(character) {\n  return hasValueInReadOnlyStringList(CHOSEONGS, character);\n}\n\n// src/canBeJongseong/canBeJongseong.ts\nfunction canBeJongseong(character) {\n  return hasValueInReadOnlyStringList(JONGSEONGS, character);\n}\n\n// src/canBeJungseong/canBeJungseong.ts\nfunction canBeJungseong(character) {\n  return hasValueInReadOnlyStringList(JUNSEONGS, character);\n}\n\n// src/combineVowels/combineVowels.ts\nfunction combineVowels(vowel1, vowel2) {\n  var _a, _b;\n  return (_b = (_a = Object.entries(DISASSEMBLED_VOWELS_BY_VOWEL).find(([, value]) => value === `${vowel1}${vowel2}`)) == null ? void 0 : _a[0]) != null ? _b : `${vowel1}${vowel2}`;\n}\n\n// src/combineCharacter/combineCharacter.ts\nfunction combineCharacter(choseong, jungseong, jongseong = \"\") {\n  if (canBeChoseong(choseong) === false || canBeJungseong(jungseong) === false || canBeJongseong(jongseong) === false) {\n    throw new Error(`Invalid hangul Characters: ${choseong}, ${jungseong}, ${jongseong}`);\n  }\n  const numOfJungseongs = JUNSEONGS.length;\n  const numOfJongseongs = JONGSEONGS.length;\n  const choseongIndex = CHOSEONGS.indexOf(choseong);\n  const jungseongIndex = JUNSEONGS.indexOf(jungseong);\n  const jongseongIndex = JONGSEONGS.indexOf(jongseong);\n  const choseongOfTargetConsonant = choseongIndex * numOfJungseongs * numOfJongseongs;\n  const choseongOfTargetVowel = jungseongIndex * numOfJongseongs;\n  const unicode = COMPLETE_HANGUL_START_CHARCODE + choseongOfTargetConsonant + choseongOfTargetVowel + jongseongIndex;\n  return String.fromCharCode(unicode);\n}\n\n// src/hasBatchim/hasBatchim.ts\nfunction hasBatchim(str, options) {\n  const lastChar = str[str.length - 1];\n  if (lastChar == null) {\n    return false;\n  }\n  const charCode = lastChar.charCodeAt(0);\n  const isNotCompleteHangul = charCode < COMPLETE_HANGUL_START_CHARCODE || charCode > COMPLETE_HANGUL_END_CHARCODE;\n  if (isNotCompleteHangul) {\n    return false;\n  }\n  const batchimCode = (charCode - COMPLETE_HANGUL_START_CHARCODE) % NUMBER_OF_JONGSEONG;\n  const batchimLength = JONGSEONGS[batchimCode].length;\n  switch (options == null ? void 0 : options.only) {\n    case \"single\": {\n      return batchimLength === 1;\n    }\n    case \"double\": {\n      return batchimLength === 2;\n    }\n    default: {\n      return batchimCode > 0;\n    }\n  }\n}\n\n// src/removeLastCharacter/removeLastCharacter.ts\nfunction removeLastCharacter(words) {\n  const lastCharacter = words[words.length - 1];\n  if (lastCharacter == null) {\n    return \"\";\n  }\n  const result = (() => {\n    const disassembleLastCharacter = disassembleToGroups(lastCharacter);\n    const [lastCharacterWithoutLastAlphabet] = excludeLastElement(disassembleLastCharacter[0]);\n    if (lastCharacterWithoutLastAlphabet.length <= 3) {\n      const [first, middle, last] = lastCharacterWithoutLastAlphabet;\n      if (middle != null) {\n        return canBeJungseong(last) ? combineCharacter(first, `${middle}${last}`) : combineCharacter(first, middle, last);\n      }\n      return first;\n    } else {\n      const [first, firstJungsung, secondJungsung, firstJongsung] = lastCharacterWithoutLastAlphabet;\n      return combineCharacter(first, `${firstJungsung}${secondJungsung}`, firstJongsung);\n    }\n  })();\n  return [words.substring(0, words.length - 1), result].join(\"\");\n}\n\n// src/_internal/hangul.ts\nfunction isHangulCharacter(character) {\n  return /^[가-힣]$/.test(character);\n}\nfunction isHangulAlphabet(character) {\n  return /^[ㄱ-ㅣ]$/.test(character);\n}\nfunction binaryAssembleAlphabets(source, nextCharacter) {\n  if (canBeJungseong(`${source}${nextCharacter}`)) {\n    return combineVowels(source, nextCharacter);\n  }\n  const isConsonantSource = canBeJungseong(source) === false;\n  if (isConsonantSource && canBeJungseong(nextCharacter)) {\n    return combineCharacter(source, nextCharacter);\n  }\n  return joinString(source, nextCharacter);\n}\nfunction linkHangulCharacters(source, nextCharacter) {\n  const sourceJamo = disassembleToGroups(source)[0];\n  const [, lastJamo] = excludeLastElement(sourceJamo);\n  return joinString(removeLastCharacter(source), combineCharacter(lastJamo, nextCharacter));\n}\nfunction binaryAssembleCharacters(source, nextCharacter) {\n  assert(\n    isHangulCharacter(source) || isHangulAlphabet(source),\n    `Invalid source character: ${source}. Source must be one character.`\n  );\n  assert(\n    isHangulAlphabet(nextCharacter),\n    `Invalid next character: ${nextCharacter}. Next character must be one of the choseong, jungseong, or jongseong.`\n  );\n  const sourceJamos = disassembleToGroups(source)[0];\n  const isSingleCharacter = sourceJamos.length === 1;\n  if (isSingleCharacter) {\n    const sourceCharacter = sourceJamos[0];\n    return binaryAssembleAlphabets(sourceCharacter, nextCharacter);\n  }\n  const [restJamos, lastJamo] = excludeLastElement(sourceJamos);\n  const secondaryLastJamo = excludeLastElement(restJamos)[1];\n  const needLinking = canBeChoseong(lastJamo) && canBeJungseong(nextCharacter);\n  if (needLinking) {\n    return linkHangulCharacters(source, nextCharacter);\n  }\n  const fixConsonant = curriedCombineCharacter;\n  const combineJungseong = fixConsonant(restJamos[0]);\n  if (canBeJungseong(`${lastJamo}${nextCharacter}`)) {\n    return combineJungseong(`${lastJamo}${nextCharacter}`)();\n  }\n  if (canBeJungseong(`${secondaryLastJamo}${lastJamo}`) && canBeJongseong(nextCharacter)) {\n    return combineJungseong(`${secondaryLastJamo}${lastJamo}`)(nextCharacter);\n  }\n  if (canBeJungseong(lastJamo) && canBeJongseong(nextCharacter)) {\n    return combineJungseong(lastJamo)(nextCharacter);\n  }\n  const fixVowel = combineJungseong;\n  const combineJongseong = fixVowel(\n    canBeJungseong(`${restJamos[1]}${restJamos[2]}`) ? `${restJamos[1]}${restJamos[2]}` : restJamos[1]\n  );\n  const lastConsonant = lastJamo;\n  if (hasBatchim(source, {\n    only: \"single\"\n  }) && canBeJongseong(`${lastConsonant}${nextCharacter}`)) {\n    return combineJongseong(`${lastConsonant}${nextCharacter}`);\n  }\n  return joinString(source, nextCharacter);\n}\nfunction binaryAssemble(source, nextCharacter) {\n  const [rest, lastCharacter] = excludeLastElement(source.split(\"\"));\n  const needJoinString = isBlank(lastCharacter) || isBlank(nextCharacter);\n  return joinString(\n    ...rest,\n    needJoinString ? joinString(lastCharacter, nextCharacter) : binaryAssembleCharacters(lastCharacter, nextCharacter)\n  );\n}\nvar curriedCombineCharacter = (choseong) => (jungseong) => (jongseong = \"\") => combineCharacter(choseong, jungseong, jongseong);\n\n// src/assemble/assemble.ts\nfunction assemble(fragments) {\n  const disassembled = disassemble(fragments.join(\"\")).split(\"\");\n  return disassembled.reduce(binaryAssemble);\n}\n\n// src/convertHangulToQwerty/constants.ts\nvar HANGUL_TO_QWERTY_KEYBOARD_MAP = {\n  \\u3131: \"r\",\n  \\u3132: \"R\",\n  \\u3134: \"s\",\n  \\u3137: \"e\",\n  \\u3138: \"E\",\n  \\u3139: \"f\",\n  \\u3141: \"a\",\n  \\u3142: \"q\",\n  \\u3143: \"Q\",\n  \\u3145: \"t\",\n  \\u3146: \"T\",\n  \\u3147: \"d\",\n  \\u3148: \"w\",\n  \\u3149: \"W\",\n  \\u314A: \"c\",\n  \\u314B: \"z\",\n  \\u314C: \"x\",\n  \\u314D: \"v\",\n  \\u314E: \"g\",\n  \\u314F: \"k\",\n  \\u3150: \"o\",\n  \\u3151: \"i\",\n  \\u3152: \"O\",\n  \\u3153: \"j\",\n  \\u3154: \"p\",\n  \\u3155: \"u\",\n  \\u3156: \"P\",\n  \\u3157: \"h\",\n  \\u315B: \"y\",\n  \\u315C: \"n\",\n  \\u3160: \"b\",\n  \\u3161: \"m\",\n  \\u3163: \"l\"\n};\n\n// src/convertHangulToQwerty/convertHangulToQwerty.ts\nfunction convertHangulToQwerty(word) {\n  if (!word) {\n    return \"\";\n  }\n  return disassemble(word).split(\"\").map(\n    (inputText) => hasProperty(HANGUL_TO_QWERTY_KEYBOARD_MAP, inputText) ? HANGUL_TO_QWERTY_KEYBOARD_MAP[inputText] : inputText\n  ).join(\"\");\n}\n\n// src/convertQwertyToAlphabet/constants.ts\nvar QWERTY_KEYBOARD_MAP = {\n  q: \"\\u3142\",\n  Q: \"\\u3143\",\n  w: \"\\u3148\",\n  W: \"\\u3149\",\n  e: \"\\u3137\",\n  E: \"\\u3138\",\n  r: \"\\u3131\",\n  R: \"\\u3132\",\n  t: \"\\u3145\",\n  T: \"\\u3146\",\n  y: \"\\u315B\",\n  Y: \"\\u315B\",\n  u: \"\\u3155\",\n  U: \"\\u3155\",\n  i: \"\\u3151\",\n  I: \"\\u3151\",\n  o: \"\\u3150\",\n  O: \"\\u3152\",\n  p: \"\\u3154\",\n  P: \"\\u3156\",\n  a: \"\\u3141\",\n  A: \"\\u3141\",\n  s: \"\\u3134\",\n  S: \"\\u3134\",\n  d: \"\\u3147\",\n  D: \"\\u3147\",\n  f: \"\\u3139\",\n  F: \"\\u3139\",\n  g: \"\\u314E\",\n  G: \"\\u314E\",\n  h: \"\\u3157\",\n  H: \"\\u3157\",\n  j: \"\\u3153\",\n  J: \"\\u3153\",\n  k: \"\\u314F\",\n  K: \"\\u314F\",\n  l: \"\\u3163\",\n  L: \"\\u3163\",\n  z: \"\\u314B\",\n  Z: \"\\u314B\",\n  x: \"\\u314C\",\n  X: \"\\u314C\",\n  c: \"\\u314A\",\n  C: \"\\u314A\",\n  v: \"\\u314D\",\n  V: \"\\u314D\",\n  b: \"\\u3160\",\n  B: \"\\u3160\",\n  n: \"\\u315C\",\n  N: \"\\u315C\",\n  m: \"\\u3161\",\n  M: \"\\u3161\"\n};\n\n// src/convertQwertyToAlphabet/convertQwertyToAlphabet.ts\nfunction convertQwertyToAlphabet(word) {\n  return word.split(\"\").map((inputText) => hasProperty(QWERTY_KEYBOARD_MAP, inputText) ? QWERTY_KEYBOARD_MAP[inputText] : inputText).join(\"\");\n}\n\n// src/convertQwertyToHangul/convertQwertyToHangul.ts\nfunction convertQwertyToHangul(word) {\n  if (!word) {\n    return \"\";\n  }\n  return assemble([...convertQwertyToAlphabet(word)]);\n}\n\n// src/days/constants.ts\nvar DAYS_MAP = {\n  1: \"\\uD558\\uB8E8\",\n  2: \"\\uC774\\uD2C0\",\n  3: \"\\uC0AC\\uD758\",\n  4: \"\\uB098\\uD758\",\n  5: \"\\uB2F7\\uC0C8\",\n  6: \"\\uC5FF\\uC0C8\",\n  7: \"\\uC774\\uB808\",\n  8: \"\\uC5EC\\uB4DC\\uB808\",\n  9: \"\\uC544\\uD750\\uB808\",\n  10: \"\\uC5F4\",\n  20: \"\\uC2A4\\uBB34\"\n};\nvar DAYS_ONLY_TENS_MAP = {\n  10: \"\\uC5F4\\uD758\",\n  20: \"\\uC2A4\\uBB34\\uB0A0\",\n  30: \"\\uC11C\\uB978\\uB0A0\"\n};\n\n// src/days/days.ts\nfunction days(num) {\n  return getNumberWord(num);\n}\nfunction getNumberWord(num) {\n  validateNumber(num);\n  const tens = Math.floor(num / 10) * 10;\n  const ones = num % 10;\n  if (ones === 0 && hasProperty(DAYS_ONLY_TENS_MAP, tens)) {\n    return DAYS_ONLY_TENS_MAP[tens];\n  }\n  const tensWord = hasProperty(DAYS_MAP, tens) ? DAYS_MAP[tens] : \"\";\n  const onesWord = DAYS_MAP[ones];\n  return `${tensWord}${onesWord}`;\n}\nfunction validateNumber(num) {\n  if (Number.isNaN(num) || num <= 0 || num > 30 || !Number.isInteger(num) || !Number.isFinite(num)) {\n    throw new Error(\"\\uC9C0\\uC6D0\\uD558\\uC9C0 \\uC54A\\uB294 \\uC22B\\uC790\\uC785\\uB2C8\\uB2E4.\");\n  }\n}\n\n// src/getChoseong/constants.ts\nvar JASO_HANGUL_NFD = {\n  START_CHOSEONG: _JASO_HANGUL_NFD[0],\n  // ㄱ\n  START_JUNGSEONG: _JASO_HANGUL_NFD[1],\n  // ㅏ\n  START_JONGSEONG: _JASO_HANGUL_NFD[2],\n  // ㄱ\n  END_CHOSEONG: _JASO_HANGUL_NFD[3],\n  // ㅎ\n  END_JUNGSEONG: _JASO_HANGUL_NFD[4],\n  // ㅣ\n  END_JONGSEONG: _JASO_HANGUL_NFD[5]\n  // ㅎ\n};\n\n// src/getChoseong/getChoseong.ts\nfunction getChoseong(word) {\n  return word.normalize(\"NFD\").replace(EXTRACT_CHOSEONG_REGEX, \"\").replace(CHOOSE_NFD_CHOSEONG_REGEX, ($0) => CHOSEONGS[$0.charCodeAt(0) - 4352]);\n}\nvar EXTRACT_CHOSEONG_REGEX = new RegExp(\n  `[^\\\\u${JASO_HANGUL_NFD.START_CHOSEONG.toString(16)}-\\\\u${JASO_HANGUL_NFD.END_CHOSEONG.toString(16)}\\u3131-\\u314E\\\\s]+`,\n  \"ug\"\n);\nvar CHOOSE_NFD_CHOSEONG_REGEX = new RegExp(\n  `[\\\\u${JASO_HANGUL_NFD.START_CHOSEONG.toString(16)}-\\\\u${JASO_HANGUL_NFD.END_CHOSEONG.toString(16)}]`,\n  \"g\"\n);\n\n// src/josa/josa.ts\nvar \\uB85C_\\uC870\\uC0AC = [\"\\uC73C\\uB85C/\\uB85C\", \"\\uC73C\\uB85C\\uC11C/\\uB85C\\uC11C\", \"\\uC73C\\uB85C\\uC368/\\uB85C\\uC368\", \"\\uC73C\\uB85C\\uBD80\\uD130/\\uB85C\\uBD80\\uD130\"];\nfunction josa(word, josa2) {\n  if (word.length === 0) {\n    return word;\n  }\n  return word + josaPicker(word, josa2);\n}\njosa.pick = josaPicker;\nfunction josaPicker(word, josa2) {\n  var _a;\n  if (word.length === 0) {\n    return josa2.split(\"/\")[0];\n  }\n  const has\\uBC1B\\uCE68 = hasBatchim(word);\n  let index = has\\uBC1B\\uCE68 ? 0 : 1;\n  const is\\uC885\\uC131\\u3139 = has\\uBC1B\\uCE68 && ((_a = disassembleCompleteCharacter(word[word.length - 1])) == null ? void 0 : _a.jongseong) === \"\\u3139\";\n  const isCaseOf\\uB85C = has\\uBC1B\\uCE68 && is\\uC885\\uC131\\u3139 && \\uB85C_\\uC870\\uC0AC.includes(josa2);\n  if (josa2 === \"\\uC640/\\uACFC\" || isCaseOf\\uB85C) {\n    index = index === 0 ? 1 : 0;\n  }\n  const isEndsWith\\uC774 = word[word.length - 1] === \"\\uC774\";\n  if (josa2 === \"\\uC774\\uC5D0\\uC694/\\uC608\\uC694\" && isEndsWith\\uC774) {\n    index = 1;\n  }\n  return josa2.split(\"/\")[index];\n}\n\n// src/numberToHangul/numberToHangul.ts\nfunction numberToHangul(input, options) {\n  if (typeof input !== \"number\" || Number.isNaN(input)) {\n    throw new Error(\"\\uC720\\uD6A8\\uD55C \\uC22B\\uC790\\uB97C \\uC785\\uB825\\uD574\\uC8FC\\uC138\\uC694.\");\n  }\n  if (input === Infinity) {\n    return \"\\uBB34\\uD55C\\uB300\";\n  }\n  if (input === -Infinity) {\n    return (options == null ? void 0 : options.spacing) ? \"\\uB9C8\\uC774\\uB108\\uC2A4 \\uBB34\\uD55C\\uB300\" : \"\\uB9C8\\uC774\\uB108\\uC2A4\\uBB34\\uD55C\\uB300\";\n  }\n  if (input === 0) {\n    return \"\\uC601\";\n  }\n  const isNegative = input < 0;\n  const absoluteInput = Math.abs(input);\n  const [integerPart, decimalPart] = absoluteInput.toString().split(\".\");\n  const koreanParts = [];\n  let remainingDigits = integerPart;\n  let placeIndex = 0;\n  while (remainingDigits.length > 0) {\n    const currentPart = remainingDigits.slice(-4);\n    const koreanNumber = numberToKoreanUpToThousand(Number(currentPart));\n    if (koreanNumber !== \"\") {\n      koreanParts.unshift(`${koreanNumber}${HANGUL_DIGITS[placeIndex]}`);\n    }\n    remainingDigits = remainingDigits.slice(0, -4);\n    placeIndex++;\n  }\n  let result = koreanParts.filter((part) => part !== \"\").join((options == null ? void 0 : options.spacing) ? \" \" : \"\").trim();\n  if (integerPart === \"0\") {\n    result = \"\\uC601\";\n  }\n  if (decimalPart) {\n    const decimalKorean = decimalPart.split(\"\").map((digit) => HANGUL_NUMBERS[Number(digit)]).join(\"\");\n    result += (options == null ? void 0 : options.spacing) ? \"\\uC810 \" + decimalKorean : \"\\uC810\" + decimalKorean;\n  }\n  if (isNegative) {\n    result = (options == null ? void 0 : options.spacing) ? `\\uB9C8\\uC774\\uB108\\uC2A4 ${result}` : `\\uB9C8\\uC774\\uB108\\uC2A4${result}`;\n  }\n  return result;\n}\nfunction numberToKoreanUpToThousand(num) {\n  const koreanDigits = num.toString().split(\"\").reverse().map((digit, index) => digit === \"0\" ? \"\" : HANGUL_NUMBERS[Number(digit)] + HANGUL_CARDINAL[index]).reverse().join(\"\");\n  return koreanDigits.replace(/일천/, \"\\uCC9C\").replace(/일백/, \"\\uBC31\").replace(/일십/, \"\\uC2ED\") || \"\";\n}\n\n// src/numberToHangulMixed/numberToHangulMixed.ts\nfunction numberToHangulMixed(input, options) {\n  if (typeof input !== \"number\" || Number.isNaN(input)) {\n    throw new Error(\"\\uC720\\uD6A8\\uD55C \\uC22B\\uC790\\uB97C \\uC785\\uB825\\uD574\\uC8FC\\uC138\\uC694.\");\n  }\n  if (input === Infinity) {\n    return \"\\uBB34\\uD55C\\uB300\";\n  }\n  if (input === -Infinity) {\n    return \"-\\uBB34\\uD55C\\uB300\";\n  }\n  if (input === 0) {\n    return \"0\";\n  }\n  const isNegative = input < 0;\n  const absoluteInput = Math.abs(input);\n  const [integerPart, decimalPart] = absoluteInput.toString().split(\".\");\n  const koreanParts = [];\n  let remainingDigits = integerPart;\n  let placeIndex = 0;\n  while (remainingDigits.length > 0) {\n    const currentPart = remainingDigits.slice(-4);\n    if (Number(currentPart) > 0) {\n      koreanParts.unshift(`${Number(currentPart).toLocaleString()}${HANGUL_DIGITS[placeIndex]}`);\n    }\n    koreanParts.unshift(\"\");\n    remainingDigits = remainingDigits.slice(0, -4);\n    placeIndex++;\n  }\n  let result = koreanParts.filter((part) => part !== \"\").join((options == null ? void 0 : options.spacing) ? \" \" : \"\").trim();\n  if (integerPart === \"0\") {\n    result = \"0\";\n  }\n  if (decimalPart) {\n    result += \".\" + decimalPart;\n  }\n  return isNegative ? \"-\" + result : result;\n}\n\n// src/standardizePronunciation/constants.ts\nvar \\uC74C\\uAC00\\uAC00_\\uC5C6\\uB294_\\uC790\\uC74C = \"\\u3147\";\nvar \\uD55C\\uAE00_\\uC790\\uBAA8 = [\"\\uAE30\\uC5ED\", \"\\uB2C8\\uC740\", \"\\uB9AC\\uC744\", \"\\uBBF8\\uC74C\", \"\\uBE44\\uC74D\", \"\\uC2DC\\uC637\", \"\\uC774\\uC751\"];\nvar \\uD2B9\\uBCC4\\uD55C_\\uD55C\\uAE00_\\uC790\\uBAA8 = [\"\\uB514\\uADFF\", \"\\uC9C0\\uC752\", \"\\uCE58\\uC753\", \"\\uD0A4\\uC754\", \"\\uD2F0\\uC755\", \"\\uD53C\\uC756\", \"\\uD788\\uC757\"];\nvar \\uD2B9\\uBCC4\\uD55C_\\uD55C\\uAE00_\\uC790\\uBAA8\\uC758_\\uBC1C\\uC74C = {\n  \\u3137: \"\\u3145\",\n  \\u3148: \"\\u3145\",\n  \\u314A: \"\\u3145\",\n  \\u314C: \"\\u3145\",\n  \\u314E: \"\\u3145\",\n  \\u314B: \"\\u3131\",\n  \\u314D: \"\\u3142\"\n};\nvar \\uC74C\\uC758_\\uB3D9\\uD654_\\uBC1B\\uCE68 = {\n  \\u3137: \"\\u3148\",\n  \\u314C: \"\\u314A\",\n  \\u3139\\u314C: \"\\u314A\"\n};\nvar \\u3134\\u3139\\uC774_\\uB367\\uB098\\uB294_\\uBAA8\\uC74C = [\"\\u314F\", \"\\u3150\", \"\\u3153\", \"\\u3154\", \"\\u3157\", \"\\u315C\", \"\\u315F\"];\nvar \\u3134\\u3139\\uC774_\\uB367\\uB098\\uB294_\\uD6C4\\uC18D\\uC74C\\uC808_\\uBAA8\\uC74C = [\"\\u3151\", \"\\u3155\", \"\\u315B\", \"\\u3160\", \"\\u3163\", \"\\u3152\", \"\\u3156\"];\nvar \\u3134\\u3139\\uC774_\\uB367\\uB098\\uC11C_\\uBC1B\\uCE68_\\u3134_\\uBCC0\\uD658 = [\"\\u3131\", \"\\u3134\", \"\\u3137\", \"\\u3141\", \"\\u3142\", \"\\u3147\"];\nvar \\u3134\\u3139\\uC774_\\uB367\\uB098\\uC11C_\\uBC1B\\uCE68_\\u3139_\\uBCC0\\uD658 = [\"\\u3139\"];\nvar \\uC790\\uC74C\\uB3D9\\uD654_\\uBC1B\\uCE68_\\u3134_\\uBCC0\\uD658 = [\"\\u3141\", \"\\u3147\", \"\\u3131\", \"\\u3142\"];\nvar \\uBE44\\uC74C\\uD654_\\uBC1B\\uCE68_\\u3147_\\uBCC0\\uD658 = [\"\\u3131\", \"\\u3132\", \"\\u314B\", \"\\u3131\\u3145\", \"\\u3139\\u3131\"];\nvar \\uBE44\\uC74C\\uD654_\\uBC1B\\uCE68_\\u3134_\\uBCC0\\uD658 = [\"\\u3137\", \"\\u3145\", \"\\u3146\", \"\\u3148\", \"\\u314A\", \"\\u314C\", \"\\u314E\"];\nvar \\uBE44\\uC74C\\uD654_\\uBC1B\\uCE68_\\u3141_\\uBCC0\\uD658 = [\"\\u3142\", \"\\u314D\", \"\\u3139\\u3142\", \"\\u3139\\u314D\", \"\\u3142\\u3145\"];\nvar \\uBC1C\\uC74C\\uBCC0\\uD658_\\uBC1B\\uCE68_\\u314E = [\"\\u314E\", \"\\u3134\\u314E\", \"\\u3139\\u314E\"];\nvar \\uBC1C\\uC74C\\uBCC0\\uD658_\\uBC1B\\uCE68_\\u314E_\\uBC1C\\uC74C = {\n  \\u3131: \"\\u314B\",\n  \\u3137: \"\\u314C\",\n  \\u3148: \"\\u314A\",\n  \\u3145: \"\\u3146\"\n};\nvar \\uBC1C\\uC74C\\uBCC0\\uD658_\\uCCAB\\uC18C\\uB9AC_\\u314E = [\"\\u3131\", \"\\u3139\\u3131\", \"\\u3137\", \"\\u3142\", \"\\u3139\\u3142\", \"\\u3148\", \"\\u3134\\u3148\"];\nvar \\uBC1C\\uC74C\\uBCC0\\uD658_\\uCCAB\\uC18C\\uB9AC_\\u314E_\\uBC1C\\uC74C = {\n  \\u3131: \"\\u314B\",\n  \\u3139\\u3131: \"\\u314B\",\n  \\u3137: \"\\u314C\",\n  \\u3142: \"\\u314D\",\n  \\u3139\\u3142: \"\\u314D\",\n  \\u3148: \"\\u314A\",\n  \\u3134\\u3148: \"\\u314A\"\n};\nvar \\uBC1B\\uCE68_\\uB300\\uD45C\\uC74C_\\uBC1C\\uC74C = {\n  \\u3132: \"\\u3131\",\n  \\u314B: \"\\u3131\",\n  \\u3131\\u3145: \"\\u3131\",\n  \\u3139\\u3131: \"\\u3131\",\n  \\u3145: \"\\u3137\",\n  \\u3146: \"\\u3137\",\n  \\u3148: \"\\u3137\",\n  \\u314A: \"\\u3137\",\n  \\u314C: \"\\u3137\",\n  \\u314D: \"\\u3142\",\n  \\u3142\\u3145: \"\\u3142\",\n  \\u3139\\u314D: \"\\u3142\",\n  \\u3134\\u3148: \"\\u3134\",\n  \\u3139\\u3142: \"\\u3139\",\n  \\u3139\\u3145: \"\\u3139\",\n  \\u3139\\u314C: \"\\u3139\",\n  \\u3139\\u3141: \"\\u3141\"\n};\nvar \\uB41C\\uC18C\\uB9AC = {\n  \\u3131: \"\\u3132\",\n  \\u3137: \"\\u3138\",\n  \\u3142: \"\\u3143\",\n  \\u3145: \"\\u3146\",\n  \\u3148: \"\\u3149\"\n};\nvar \\uB41C\\uC18C\\uB9AC_\\uBC1B\\uCE68 = [\n  \"\\u3131\",\n  \"\\u3132\",\n  \"\\u314B\",\n  \"\\u3131\\u3145\",\n  \"\\u3139\\u3131\",\n  \"\\u3137\",\n  \"\\u3145\",\n  \"\\u3146\",\n  \"\\u3148\",\n  \"\\u314A\",\n  \"\\u314C\",\n  \"\\u3142\",\n  \"\\u314D\",\n  \"\\u3139\\u3142\",\n  \"\\u3139\\u314D\",\n  \"\\u3142\\u3145\"\n];\nvar \\uC5B4\\uAC04_\\uBC1B\\uCE68 = [\"\\u3134\", \"\\u3134\\u3148\", \"\\u3141\", \"\\u3139\\u3141\", \"\\u3139\\u3142\", \"\\u3139\\u314C\"];\n\n// src/standardizePronunciation/rules/rules.utils.ts\nfunction replace\\uBC1B\\uCE68\\u314E(currentSyllable) {\n  return currentSyllable.jongseong.replace(\"\\u314E\", \"\");\n}\n\n// src/standardizePronunciation/rules/transform12th.ts\nfunction transform12th(currentSyllable, nextSyllable) {\n  let current = __spreadValues({}, currentSyllable);\n  let next = nextSyllable ? __spreadValues({}, nextSyllable) : nextSyllable;\n  if (!current.jongseong) {\n    return {\n      current,\n      next\n    };\n  }\n  if (arrayIncludes(\\uBC1C\\uC74C\\uBCC0\\uD658_\\uBC1B\\uCE68_\\u314E, current.jongseong)) {\n    if (next) {\n      ({ current, next } = handleNextChoseongIs\\u3131\\u3137\\u3148\\u3145(current, next));\n      ({ current, next } = handleNextChoseongIs\\u3134(current, next));\n      ({ current, next } = handleNextChoseongIs\\u3147(current, next));\n    }\n    if (!next) {\n      ({ current } = handleCurrentJongseongIs\\u3147(current));\n    }\n  }\n  ({ current, next } = handleNextChoseongIs\\u314E(current, next));\n  return {\n    current,\n    next\n  };\n}\nfunction handleNextChoseongIs\\u3131\\u3137\\u3148\\u3145(current, next) {\n  const updatedCurrent = __spreadValues({}, current);\n  const updatedNext = __spreadValues({}, next);\n  if (arrayIncludes([\"\\u3131\", \"\\u3137\", \"\\u3148\", \"\\u3145\"], updatedNext.choseong)) {\n    updatedNext.choseong = \\uBC1C\\uC74C\\uBCC0\\uD658_\\uBC1B\\uCE68_\\u314E_\\uBC1C\\uC74C[updatedNext.choseong];\n    updatedCurrent.jongseong = replace\\uBC1B\\uCE68\\u314E(updatedCurrent);\n  }\n  return { current: updatedCurrent, next: updatedNext };\n}\nfunction handleNextChoseongIs\\u3134(current, next) {\n  const updatedCurrent = __spreadValues({}, current);\n  const updatedNext = __spreadValues({}, next);\n  if (updatedNext.choseong === \"\\u3134\" && arrayIncludes([\"\\u3134\\u314E\", \"\\u3139\\u314E\"], updatedCurrent.jongseong)) {\n    updatedCurrent.jongseong = replace\\uBC1B\\uCE68\\u314E(updatedCurrent);\n  }\n  return { current: updatedCurrent, next: updatedNext };\n}\nfunction handleNextChoseongIs\\u3147(current, next) {\n  const updatedCurrent = __spreadValues({}, current);\n  const updatedNext = __spreadValues({}, next);\n  if (updatedNext.choseong === \\uC74C\\uAC00\\uAC00_\\uC5C6\\uB294_\\uC790\\uC74C) {\n    if (arrayIncludes([\"\\u3134\\u314E\", \"\\u3139\\u314E\"], updatedCurrent.jongseong)) {\n      updatedCurrent.jongseong = replace\\uBC1B\\uCE68\\u314E(updatedCurrent);\n    } else {\n      updatedCurrent.jongseong = \"\";\n    }\n  } else {\n    updatedCurrent.jongseong = replace\\uBC1B\\uCE68\\u314E(updatedCurrent);\n  }\n  return { current: updatedCurrent, next: updatedNext };\n}\nfunction handleCurrentJongseongIs\\u3147(current) {\n  const updatedCurrent = __spreadValues({}, current);\n  updatedCurrent.jongseong = replace\\uBC1B\\uCE68\\u314E(updatedCurrent);\n  return { current: updatedCurrent };\n}\nfunction handleNextChoseongIs\\u314E(current, next) {\n  const updatedCurrent = __spreadValues({}, current);\n  const updatedNext = next ? __spreadValues({}, next) : next;\n  if (arrayIncludes(\\uBC1C\\uC74C\\uBCC0\\uD658_\\uCCAB\\uC18C\\uB9AC_\\u314E, updatedCurrent.jongseong) && arrayIncludes([\"\\u314E\"], updatedNext == null ? void 0 : updatedNext.choseong)) {\n    updatedNext.choseong = \\uBC1C\\uC74C\\uBCC0\\uD658_\\uCCAB\\uC18C\\uB9AC_\\u314E_\\uBC1C\\uC74C[updatedCurrent.jongseong];\n    if (updatedCurrent.jongseong.length === 1) {\n      updatedCurrent.jongseong = \"\";\n    } else {\n      updatedCurrent.jongseong = updatedCurrent.jongseong[0];\n    }\n  }\n  return { current: updatedCurrent, next: updatedNext };\n}\n\n// src/standardizePronunciation/rules/transform13And14th.ts\nvar \\uBC1B\\uCE68\\uC758\\uAE38\\uC774 = {\n  \\uD640\\uBC1B\\uCE68: 1,\n  \\uC30D_\\uACB9\\uBC1B\\uCE68: 2\n};\nfunction transform13And14th(currentSyllable, nextSyllable) {\n  let current = __spreadValues({}, currentSyllable);\n  let next = __spreadValues({}, nextSyllable);\n  const \\uC81C13_14\\uD56D\\uC8FC\\uC694\\uC870\\uAC74 = current.jongseong && next.choseong === \\uC74C\\uAC00\\uAC00_\\uC5C6\\uB294_\\uC790\\uC74C;\n  if (!\\uC81C13_14\\uD56D\\uC8FC\\uC694\\uC870\\uAC74) {\n    return {\n      current,\n      next\n    };\n  }\n  ({ current, next } = handle\\uD651\\uBC1B\\uCE68or\\uC30D\\uBC1B\\uCE68(current, next));\n  ({ current, next } = handle\\uACB9\\uBC1B\\uCE68(current, next));\n  return {\n    current,\n    next\n  };\n}\nfunction is\\uD651\\uBC1B\\uCE68(current) {\n  return current.jongseong.length === \\uBC1B\\uCE68\\uC758\\uAE38\\uC774[\"\\uD640\\uBC1B\\uCE68\"];\n}\nfunction is\\uC30D\\uBC1B\\uCE68(current) {\n  return current.jongseong.length === \\uBC1B\\uCE68\\uC758\\uAE38\\uC774[\"\\uC30D_\\uACB9\\uBC1B\\uCE68\"] && current.jongseong[0] === current.jongseong[1];\n}\nfunction is\\uACB9\\uBC1B\\uCE68(current) {\n  return current.jongseong.length === \\uBC1B\\uCE68\\uC758\\uAE38\\uC774[\"\\uC30D_\\uACB9\\uBC1B\\uCE68\"] && current.jongseong[0] !== current.jongseong[1];\n}\nfunction handle\\uD651\\uBC1B\\uCE68or\\uC30D\\uBC1B\\uCE68(current, next) {\n  const updatedCurrent = __spreadValues({}, current);\n  const updatedNext = __spreadValues({}, next);\n  if (!arrayIncludes([\"\\u3147\", \"\"], updatedCurrent.jongseong) && (is\\uD651\\uBC1B\\uCE68(updatedCurrent) || is\\uC30D\\uBC1B\\uCE68(updatedCurrent))) {\n    updatedNext.choseong = updatedCurrent.jongseong;\n    updatedCurrent.jongseong = \"\";\n  }\n  return { current: updatedCurrent, next: updatedNext };\n}\nfunction handle\\uACB9\\uBC1B\\uCE68(current, next) {\n  const updatedCurrent = __spreadValues({}, current);\n  const updatedNext = __spreadValues({}, next);\n  if (is\\uACB9\\uBC1B\\uCE68(updatedCurrent)) {\n    if (updatedCurrent.jongseong[1] === \"\\u3145\") {\n      updatedNext.choseong = \"\\u3146\";\n    } else {\n      updatedNext.choseong = updatedCurrent.jongseong[1];\n    }\n    updatedCurrent.jongseong = updatedCurrent.jongseong.replace(\n      updatedCurrent.jongseong[1],\n      \"\"\n    );\n  }\n  return { current: updatedCurrent, next: updatedNext };\n}\n\n// src/standardizePronunciation/rules/transform16th.ts\nfunction transform16th({ currentSyllable, phrase, index, nextSyllable }) {\n  let current = __spreadValues({}, currentSyllable);\n  let next = __spreadValues({}, nextSyllable);\n  const \\uC81C16\\uD56D\\uC8FC\\uC694\\uC870\\uAC74 = current.jongseong && next.choseong === \\uC74C\\uAC00\\uAC00_\\uC5C6\\uB294_\\uC790\\uC74C;\n  if (!\\uC81C16\\uD56D\\uC8FC\\uC694\\uC870\\uAC74) {\n    return {\n      current,\n      next\n    };\n  }\n  const combinedSyllables = phrase[index - 1] + phrase[index];\n  ({ current, next } = handleSpecialHangulCharacters({ current, next, combinedSyllables }));\n  ({ current, next } = handleHangulCharacters({ current, next, combinedSyllables }));\n  return {\n    current,\n    next\n  };\n}\nfunction handleSpecialHangulCharacters({\n  current,\n  next,\n  combinedSyllables\n}) {\n  const updatedCurrent = __spreadValues({}, current);\n  const updatedNext = __spreadValues({}, next);\n  if (arrayIncludes(\\uD2B9\\uBCC4\\uD55C_\\uD55C\\uAE00_\\uC790\\uBAA8, combinedSyllables)) {\n    const \\uB2E4\\uC74C_\\uC74C\\uC808\\uC758_\\uCD08\\uC131 = \\uD2B9\\uBCC4\\uD55C_\\uD55C\\uAE00_\\uC790\\uBAA8\\uC758_\\uBC1C\\uC74C[updatedCurrent.jongseong];\n    updatedCurrent.jongseong = \"\";\n    updatedNext.choseong = \\uB2E4\\uC74C_\\uC74C\\uC808\\uC758_\\uCD08\\uC131;\n  }\n  return { current: updatedCurrent, next: updatedNext };\n}\nfunction handleHangulCharacters({\n  current,\n  next,\n  combinedSyllables\n}) {\n  const updatedCurrent = __spreadValues({}, current);\n  const updatedNext = __spreadValues({}, next);\n  if (arrayIncludes(\\uD55C\\uAE00_\\uC790\\uBAA8, combinedSyllables)) {\n    updatedNext.choseong = updatedCurrent.jongseong;\n    if (updatedCurrent.jongseong !== \"\\u3147\") {\n      updatedCurrent.jongseong = \"\";\n    }\n  }\n  return { current: updatedCurrent, next: updatedNext };\n}\n\n// src/standardizePronunciation/rules/transform17th.ts\nfunction transform17th(currentSyllable, nextSyllable) {\n  let current = __spreadValues({}, currentSyllable);\n  let next = __spreadValues({}, nextSyllable);\n  const \\uC81C17\\uD56D\\uC8FC\\uC694\\uC870\\uAC74 = next.jungseong === \"\\u3163\";\n  if (!\\uC81C17\\uD56D\\uC8FC\\uC694\\uC870\\uAC74) {\n    return {\n      current,\n      next\n    };\n  }\n  ({ current, next } = handleChoseongIs\\u3147(current, next));\n  ({ current, next } = handleChoseongIs\\u314EAnd\\u3137(current, next));\n  return {\n    current,\n    next\n  };\n}\nfunction handleChoseongIs\\u3147(current, next) {\n  const updatedCurrent = __spreadValues({}, current);\n  const updatedNext = __spreadValues({}, next);\n  if (updatedNext.choseong === \"\\u3147\" && hasProperty(\\uC74C\\uC758_\\uB3D9\\uD654_\\uBC1B\\uCE68, updatedCurrent.jongseong)) {\n    updatedNext.choseong = \\uC74C\\uC758_\\uB3D9\\uD654_\\uBC1B\\uCE68[updatedCurrent.jongseong];\n    updatedCurrent.jongseong = updatedCurrent.jongseong === \"\\u3139\\u314C\" ? \"\\u3139\" : \"\";\n  }\n  return { current: updatedCurrent, next: updatedNext };\n}\nfunction handleChoseongIs\\u314EAnd\\u3137(current, next) {\n  const updatedCurrent = __spreadValues({}, current);\n  const updatedNext = __spreadValues({}, next);\n  if (updatedNext.choseong === \"\\u314E\" && updatedCurrent.jongseong === \"\\u3137\") {\n    updatedNext.choseong = \"\\u314A\";\n    updatedCurrent.jongseong = \"\";\n  }\n  return { current: updatedCurrent, next: updatedNext };\n}\n\n// src/standardizePronunciation/rules/transform18th.ts\nfunction transform18th(currentSyllable, nextSyllable) {\n  const current = __spreadValues({}, currentSyllable);\n  const \\uC81C18\\uD56D\\uC8FC\\uC694\\uC870\\uAC74 = current.jongseong && arrayIncludes([\"\\u3134\", \"\\u3141\"], nextSyllable.choseong);\n  if (!\\uC81C18\\uD56D\\uC8FC\\uC694\\uC870\\uAC74) {\n    return {\n      current\n    };\n  }\n  if (arrayIncludes(\\uBE44\\uC74C\\uD654_\\uBC1B\\uCE68_\\u3147_\\uBCC0\\uD658, current.jongseong)) {\n    current.jongseong = \"\\u3147\";\n  }\n  if (arrayIncludes(\\uBE44\\uC74C\\uD654_\\uBC1B\\uCE68_\\u3134_\\uBCC0\\uD658, current.jongseong)) {\n    current.jongseong = \"\\u3134\";\n  }\n  if (arrayIncludes(\\uBE44\\uC74C\\uD654_\\uBC1B\\uCE68_\\u3141_\\uBCC0\\uD658, current.jongseong)) {\n    current.jongseong = \"\\u3141\";\n  }\n  return {\n    current\n  };\n}\n\n// src/standardizePronunciation/rules/transform19th.ts\nfunction transform19th(currentSyllable, nextSyllable) {\n  const next = __spreadValues({}, nextSyllable);\n  const \\uC81C19\\uD56D\\uC870\\uAC74 = arrayIncludes(\\uC790\\uC74C\\uB3D9\\uD654_\\uBC1B\\uCE68_\\u3134_\\uBCC0\\uD658, currentSyllable.jongseong) && next.choseong === \"\\u3139\";\n  if (\\uC81C19\\uD56D\\uC870\\uAC74) {\n    next.choseong = \"\\u3134\";\n  }\n  return { next };\n}\n\n// src/standardizePronunciation/rules/transform20th.ts\nfunction transform20th(currentSyllable, nextSyllable) {\n  let current = __spreadValues({}, currentSyllable);\n  let next = __spreadValues({}, nextSyllable);\n  ({ current } = applyMainCondition(current, next));\n  ({ next } = applySupplementaryCondition(current, next));\n  return {\n    current,\n    next\n  };\n}\nfunction applyMainCondition(current, next) {\n  const updatedCurrent = __spreadValues({}, current);\n  if (updatedCurrent.jongseong === \"\\u3134\" && next.choseong === \"\\u3139\") {\n    updatedCurrent.jongseong = \"\\u3139\";\n  }\n  return { current: updatedCurrent };\n}\nfunction applySupplementaryCondition(current, next) {\n  const updatedNext = __spreadValues({}, next);\n  if (updatedNext.choseong === \"\\u3134\" && (current.jongseong === \"\\u3139\" || arrayIncludes([\"\\u3139\\u314E\", \"\\u3139\\u314C\"], current.jongseong))) {\n    updatedNext.choseong = \"\\u3139\";\n  }\n  return { next: updatedNext };\n}\n\n// src/standardizePronunciation/rules/transform9And10And11th.ts\nfunction transform9And10And11th(currentSyllable, nextSyllable) {\n  const current = __spreadValues({}, currentSyllable);\n  const is\\uC5B4\\uB9D0 = current.jongseong && !nextSyllable;\n  const is\\uC74C\\uAC00\\uC788\\uB294\\uC790\\uC74C\\uC55E = current.jongseong && (nextSyllable == null ? void 0 : nextSyllable.choseong) !== \\uC74C\\uAC00\\uAC00_\\uC5C6\\uB294_\\uC790\\uC74C;\n  const \\uC81C9_10_11\\uD56D\\uC8FC\\uC694\\uC870\\uAC74 = (is\\uC5B4\\uB9D0 || is\\uC74C\\uAC00\\uC788\\uB294\\uC790\\uC74C\\uC55E) && hasProperty(\\uBC1B\\uCE68_\\uB300\\uD45C\\uC74C_\\uBC1C\\uC74C, current.jongseong);\n  if (\\uC81C9_10_11\\uD56D\\uC8FC\\uC694\\uC870\\uAC74) {\n    current.jongseong = \\uBC1B\\uCE68_\\uB300\\uD45C\\uC74C_\\uBC1C\\uC74C[current.jongseong];\n  }\n  return { current };\n}\n\n// src/standardizePronunciation/rules/transformHardConversion.ts\nfunction transformHardConversion(currentSyllable, nextSyllable) {\n  const next = __spreadValues({}, nextSyllable);\n  if (hasProperty(\\uB41C\\uC18C\\uB9AC, next.choseong)) {\n    const \\uC81C23\\uD56D\\uC870\\uAC74 = arrayIncludes(\\uB41C\\uC18C\\uB9AC_\\uBC1B\\uCE68, currentSyllable.jongseong);\n    const \\uC81C24_25\\uD56D\\uC870\\uAC74 = arrayIncludes(\\uC5B4\\uAC04_\\uBC1B\\uCE68, currentSyllable.jongseong) && next.choseong !== \"\\u3142\";\n    if (\\uC81C23\\uD56D\\uC870\\uAC74 || \\uC81C24_25\\uD56D\\uC870\\uAC74) {\n      next.choseong = \\uB41C\\uC18C\\uB9AC[next.choseong];\n    }\n  }\n  return { next };\n}\n\n// src/standardizePronunciation/rules/transformNLAssimilation.ts\nfunction transformNLAssimilation(currentSyllable, nextSyllable) {\n  let current = __spreadValues({}, currentSyllable);\n  let next = __spreadValues({}, nextSyllable);\n  const \\u3134\\u3139\\uC774\\uB367\\uB098\\uB294\\uC870\\uAC74 = current.jongseong && next.choseong === \"\\u3147\" && arrayIncludes(\\u3134\\u3139\\uC774_\\uB367\\uB098\\uB294_\\uD6C4\\uC18D\\uC74C\\uC808_\\uBAA8\\uC74C, next.jungseong);\n  if (!\\u3134\\u3139\\uC774\\uB367\\uB098\\uB294\\uC870\\uAC74) {\n    return {\n      current,\n      next\n    };\n  }\n  ({ current, next } = apply\\u3134\\u3139\\uB367\\uB0A8(current, next));\n  return {\n    current,\n    next\n  };\n}\nfunction apply\\u3134\\u3139\\uB367\\uB0A8(current, next) {\n  const updatedCurrent = __spreadValues({}, current);\n  const updatedNext = __spreadValues({}, next);\n  if (arrayIncludes(\\u3134\\u3139\\uC774_\\uB367\\uB098\\uB294_\\uBAA8\\uC74C, updatedCurrent.jungseong)) {\n    if (arrayIncludes(\\u3134\\u3139\\uC774_\\uB367\\uB098\\uC11C_\\uBC1B\\uCE68_\\u3134_\\uBCC0\\uD658, updatedCurrent.jongseong)) {\n      updatedCurrent.jongseong = updatedCurrent.jongseong === \"\\u3131\" ? \"\\u3147\" : updatedCurrent.jongseong;\n      updatedNext.choseong = \"\\u3134\";\n    }\n    if (arrayIncludes(\\u3134\\u3139\\uC774_\\uB367\\uB098\\uC11C_\\uBC1B\\uCE68_\\u3139_\\uBCC0\\uD658, updatedCurrent.jongseong)) {\n      updatedNext.choseong = \"\\u3139\";\n    }\n  } else {\n    updatedNext.choseong = updatedCurrent.jongseong;\n  }\n  return { current: updatedCurrent, next: updatedNext };\n}\n\n// src/standardizePronunciation/standardizePronunciation.ts\nfunction standardizePronunciation(hangul, options = { hardConversion: true }) {\n  if (!hangul) {\n    return \"\";\n  }\n  const processSyllables = (syllables, phrase, options2) => syllables.map((currentSyllable, index, array) => {\n    const nextSyllable = index < array.length - 1 ? array[index + 1] : null;\n    const { current, next } = applyRules({\n      currentSyllable,\n      phrase,\n      index,\n      nextSyllable,\n      options: options2\n    });\n    if (next) {\n      array[index + 1] = next;\n    }\n    return current;\n  });\n  const transformHangulPhrase = (phrase, options2) => {\n    const { notHangulPhrase, disassembleHangul } = \\uC74C\\uC808\\uBD84\\uD574(phrase);\n    const processedSyllables = processSyllables(disassembleHangul, phrase, options2);\n    return assembleChangedHangul(processedSyllables, notHangulPhrase);\n  };\n  return hangul.split(\" \").map((phrase) => transformHangulPhrase(phrase, options)).join(\" \");\n}\nfunction \\uC74C\\uC808\\uBD84\\uD574(hangulPhrase) {\n  const notHangulPhrase = [];\n  const disassembleHangul = Array.from(hangulPhrase).filter((syllable, index) => {\n    if (!isHangulCharacter(syllable) || isHangulAlphabet(syllable)) {\n      notHangulPhrase.push({\n        index,\n        syllable\n      });\n      return false;\n    }\n    return true;\n  }).map(disassembleCompleteCharacter).filter(isNotUndefined);\n  return { notHangulPhrase, disassembleHangul };\n}\nfunction applyRules(params) {\n  const { currentSyllable, nextSyllable, index, phrase, options } = params;\n  let current = __spreadValues({}, currentSyllable);\n  let next = nextSyllable ? __spreadValues({}, nextSyllable) : nextSyllable;\n  if (next && options.hardConversion) {\n    ({ next } = transformHardConversion(current, next));\n  }\n  if (next) {\n    ({ current, next } = transform16th({\n      currentSyllable: current,\n      nextSyllable: next,\n      index,\n      phrase\n    }));\n    ({ current, next } = transform17th(current, next));\n    ({ next } = transform19th(current, next));\n    ({ current, next } = transformNLAssimilation(current, next));\n    ({ current } = transform18th(current, next));\n    ({ current, next } = transform20th(current, next));\n  }\n  ({ current, next } = transform12th(current, next));\n  if (next) {\n    ({ current, next } = transform13And14th(current, next));\n  }\n  ({ current } = transform9And10And11th(current, next));\n  return {\n    current,\n    next\n  };\n}\nfunction assembleChangedHangul(disassembleHangul, notHangulPhrase) {\n  const changedSyllables = disassembleHangul.filter(isNotUndefined).map((syllable) => combineCharacter(syllable.choseong, syllable.jungseong, syllable.jongseong));\n  for (const { index, syllable } of notHangulPhrase) {\n    changedSyllables.splice(index, 0, syllable);\n  }\n  return joinString(...changedSyllables);\n}\n\n// src/romanize/constants.ts\nvar \\uC911\\uC131_\\uC54C\\uD30C\\uBCB3_\\uBC1C\\uC74C = {\n  // ------- 단모음\n  \\u314F: \"a\",\n  \\u3153: \"eo\",\n  \\u3157: \"o\",\n  \\u315C: \"u\",\n  \\u3161: \"eu\",\n  \\u3163: \"i\",\n  \\u3150: \"ae\",\n  \\u3154: \"e\",\n  \\u315A: \"oe\",\n  \\u315F: \"wi\",\n  // -------\n  // ------- 이중모음\n  \\u3151: \"ya\",\n  \\u3155: \"yeo\",\n  \\u315B: \"yo\",\n  \\u3160: \"yu\",\n  \\u3152: \"yae\",\n  \\u3156: \"ye\",\n  \\u3158: \"wa\",\n  \\u3159: \"wae\",\n  \\u315D: \"wo\",\n  \\u315E: \"we\",\n  \\u3162: \"ui\"\n};\nvar \\uCD08\\uC131_\\uC54C\\uD30C\\uBCB3_\\uBC1C\\uC74C = {\n  // ------- 파열음\n  \\u3131: \"g\",\n  \\u3132: \"kk\",\n  \\u314B: \"k\",\n  \\u3137: \"d\",\n  \\u3138: \"tt\",\n  \\u314C: \"t\",\n  \\u3142: \"b\",\n  \\u3143: \"pp\",\n  \\u314D: \"p\",\n  // -------\n  // ------- 파찰음\n  \\u3148: \"j\",\n  \\u3149: \"jj\",\n  \\u314A: \"ch\",\n  // -------\n  // ------- 마찰음\n  \\u3145: \"s\",\n  \\u3146: \"ss\",\n  \\u314E: \"h\",\n  // -------\n  // ------- 비음\n  \\u3134: \"n\",\n  \\u3141: \"m\",\n  \\u3147: \"\",\n  // -------\n  // ------- 유음\n  \\u3139: \"r\"\n};\nvar \\uC885\\uC131_\\uC54C\\uD30C\\uBCB3_\\uBC1C\\uC74C = {\n  \\u3131: \"k\",\n  \\u3134: \"n\",\n  \\u3137: \"t\",\n  \\u3139: \"l\",\n  \\u3141: \"m\",\n  \\u3142: \"p\",\n  \\u3147: \"ng\",\n  \"\": \"\"\n};\n\n// src/romanize/romanize.ts\nfunction romanize(hangul) {\n  const changedHangul = standardizePronunciation(hangul, { hardConversion: false });\n  return changedHangul.split(\"\").map((_, i, arrayHangul) => romanizeSyllableHangul(arrayHangul, i)).join(\"\");\n}\nvar romanizeSyllableHangul = (arrayHangul, index) => {\n  const syllable = arrayHangul[index];\n  if (isHangulCharacter(syllable)) {\n    const disassemble2 = disassembleCompleteCharacter(syllable);\n    let choseong = \\uCD08\\uC131_\\uC54C\\uD30C\\uBCB3_\\uBC1C\\uC74C[disassemble2.choseong];\n    const jungseong = \\uC911\\uC131_\\uC54C\\uD30C\\uBCB3_\\uBC1C\\uC74C[assemble([disassemble2.jungseong])];\n    const jongseong = \\uC885\\uC131_\\uC54C\\uD30C\\uBCB3_\\uBC1C\\uC74C[disassemble2.jongseong];\n    if (disassemble2.choseong === \"\\u3139\" && index > 0 && isHangulCharacter(arrayHangul[index - 1])) {\n      const prevDisassemble = disassembleCompleteCharacter(arrayHangul[index - 1]);\n      if ((prevDisassemble == null ? void 0 : prevDisassemble.jongseong) === \"\\u3139\") {\n        choseong = \"l\";\n      }\n    }\n    return choseong + jungseong + jongseong;\n  }\n  if (syllable in \\uC911\\uC131_\\uC54C\\uD30C\\uBCB3_\\uBC1C\\uC74C) {\n    return \\uC911\\uC131_\\uC54C\\uD30C\\uBCB3_\\uBC1C\\uC74C[syllable];\n  }\n  if (canBeChoseong(syllable)) {\n    return \\uCD08\\uC131_\\uC54C\\uD30C\\uBCB3_\\uBC1C\\uC74C[syllable];\n  }\n  return syllable;\n};\n\n// src/susa/constants.ts\nvar SUSA_MAP = {\n  1: \"\\uD558\\uB098\",\n  2: \"\\uB458\",\n  3: \"\\uC14B\",\n  4: \"\\uB137\",\n  5: \"\\uB2E4\\uC12F\",\n  6: \"\\uC5EC\\uC12F\",\n  7: \"\\uC77C\\uACF1\",\n  8: \"\\uC5EC\\uB35F\",\n  9: \"\\uC544\\uD649\",\n  10: \"\\uC5F4\",\n  20: \"\\uC2A4\\uBB3C\",\n  30: \"\\uC11C\\uB978\",\n  40: \"\\uB9C8\\uD754\",\n  50: \"\\uC270\",\n  60: \"\\uC608\\uC21C\",\n  70: \"\\uC77C\\uD754\",\n  80: \"\\uC5EC\\uB4E0\",\n  90: \"\\uC544\\uD754\",\n  100: \"\\uBC31\"\n};\nvar SUSA_CLASSIFIER_MAP = {\n  1: \"\\uD55C\",\n  2: \"\\uB450\",\n  3: \"\\uC138\",\n  4: \"\\uB124\",\n  20: \"\\uC2A4\\uBB34\"\n};\n\n// src/susa/susa.ts\nfunction susa(num, classifier) {\n  validateNumber2(num);\n  return classifier ? getClassifierWord(num) : getNumberWord2(num);\n}\nfunction getClassifierWord(num) {\n  if (num === 20) {\n    return SUSA_CLASSIFIER_MAP[num];\n  }\n  const tens = Math.floor(num / 10) * 10;\n  const ones = num % 10;\n  const tensWord = hasProperty(SUSA_MAP, tens) ? SUSA_MAP[tens] : \"\";\n  if (ones === 0) {\n    return tensWord;\n  }\n  if (hasProperty(SUSA_CLASSIFIER_MAP, ones)) {\n    const onesWord2 = SUSA_CLASSIFIER_MAP[ones];\n    return `${tensWord}${onesWord2}`;\n  }\n  const onesWord = SUSA_MAP[ones];\n  return `${tensWord}${onesWord}`;\n}\nfunction validateNumber2(num) {\n  if (Number.isNaN(num) || num <= 0 || num > 100 || !Number.isInteger(num) || !Number.isFinite(num)) {\n    throw new Error(\"\\uC9C0\\uC6D0\\uD558\\uC9C0 \\uC54A\\uB294 \\uC22B\\uC790\\uC785\\uB2C8\\uB2E4.\");\n  }\n}\nfunction getNumberWord2(num) {\n  if (num === 100) {\n    return SUSA_MAP[100];\n  }\n  const tens = Math.floor(num / 10) * 10;\n  const ones = num % 10;\n  const tensWord = hasProperty(SUSA_MAP, tens) ? SUSA_MAP[tens] : \"\";\n  const onesWord = hasProperty(SUSA_MAP, ones) ? SUSA_MAP[ones] : \"\";\n  return `${tensWord}${onesWord}`;\n}\nexport {\n  amountToHangul,\n  assemble,\n  canBeChoseong,\n  canBeJongseong,\n  canBeJungseong,\n  combineCharacter,\n  combineVowels,\n  convertHangulToQwerty,\n  convertQwertyToAlphabet,\n  convertQwertyToHangul,\n  days,\n  disassemble,\n  disassembleCompleteCharacter,\n  disassembleToGroups,\n  getChoseong,\n  hasBatchim,\n  josa,\n  numberToHangul,\n  numberToHangulMixed,\n  removeLastCharacter,\n  romanize,\n  standardizePronunciation,\n  susa\n};\n"],"names":["Object","defineProperty","getOwnPropertySymbols","prototype","hasOwnProperty","propertyIsEnumerable","_JASO_HANGUL_NFD","normalize","map","char","charCodeAt","DISASSEMBLED_CONSONANTS_BY_CONSONANT","ㄱ","ㄲ","ㄳ","ㄴ","ㄵ","ㄶ","ㄷ","ㄸ","ㄹ","ㄺ","ㄻ","ㄼ","ㄽ","ㄾ","ㄿ","ㅀ","ㅁ","ㅂ","ㅃ","ㅄ","ㅅ","ㅆ","ㅇ","ㅈ","ㅉ","ㅊ","ㅋ","ㅌ","ㅍ","ㅎ","DISASSEMBLED_VOWELS_BY_VOWEL","ㅏ","ㅐ","ㅑ","ㅒ","ㅓ","ㅔ","ㅕ","ㅖ","ㅗ","ㅘ","ㅙ","ㅚ","ㅛ","ㅜ","ㅝ","ㅞ","ㅟ","ㅠ","ㅡ","ㅢ","ㅣ","CHOSEONGS","values","consonant","JASO_HANGUL_NFD","START_CHOSEONG","START_JUNGSEONG","START_JONGSEONG","END_CHOSEONG","END_JUNGSEONG","END_JONGSEONG","getChoseong","word","replace","EXTRACT_CHOSEONG_REGEX","CHOOSE_NFD_CHOSEONG_REGEX","$0","RegExp","toString"],"sourceRoot":""}